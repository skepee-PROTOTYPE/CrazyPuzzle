"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configForCodebase = exports.normalizeAndValidate = exports.validate = exports.assertUnique = exports.validatePrefix = exports.validateCodebase = exports.normalize = exports.DEFAULT_CODEBASE = void 0;
const error_1 = require("../error");
exports.DEFAULT_CODEBASE = "default";
function normalize(config) {
    if (!config) {
        throw new error_1.FirebaseError("No valid functions configuration detected in firebase.json");
    }
    if (Array.isArray(config)) {
        if (config.length < 1) {
            throw new error_1.FirebaseError("Requires at least one functions.source in firebase.json.");
        }
        return config;
    }
    return [config];
}
exports.normalize = normalize;
function validateCodebase(codebase) {
    if (codebase.length === 0 || codebase.length > 63 || !/^[a-z0-9_-]+$/.test(codebase)) {
        throw new error_1.FirebaseError("Invalid codebase name. Codebase must be less than 64 characters and " +
            "can contain only lowercase letters, numeric characters, underscores, and dashes.");
    }
}
exports.validateCodebase = validateCodebase;
function validatePrefix(prefix) {
    if (prefix.length > 30) {
        throw new error_1.FirebaseError("Invalid prefix. Prefix must be 30 characters or less.");
    }
    if (!/^[a-z](?:[a-z0-9-]*[a-z0-9])?$/.test(prefix)) {
        throw new error_1.FirebaseError("Invalid prefix. Prefix must start with a lowercase letter, can contain only lowercase letters, numeric characters, and dashes, and cannot start or end with a dash.");
    }
}
exports.validatePrefix = validatePrefix;
function validateSingle(config) {
    if (!config.source) {
        throw new error_1.FirebaseError("codebase source must be specified");
    }
    if (!config.codebase) {
        config.codebase = exports.DEFAULT_CODEBASE;
    }
    validateCodebase(config.codebase);
    if (config.prefix) {
        validatePrefix(config.prefix);
    }
    return Object.assign(Object.assign({}, config), { source: config.source, codebase: config.codebase });
}
function assertUnique(config, property, propval) {
    const values = new Set();
    if (propval) {
        values.add(propval);
    }
    for (const single of config) {
        const value = single[property];
        if (values.has(value)) {
            throw new error_1.FirebaseError(`functions.${property} must be unique but '${value}' was used more than once.`);
        }
        values.add(value);
    }
}
exports.assertUnique = assertUnique;
function assertUniqueSourcePrefixPair(config) {
    var _a;
    const sourcePrefixPairs = new Set();
    for (const c of config) {
        const key = JSON.stringify({ source: c.source, prefix: c.prefix || "" });
        if (sourcePrefixPairs.has(key)) {
            throw new error_1.FirebaseError(`More than one functions config specifies the same source directory ('${c.source}') and prefix ('${(_a = c.prefix) !== null && _a !== void 0 ? _a : ""}'). Please add a unique 'prefix' to each function configuration that shares this source to resolve the conflict.`);
        }
        sourcePrefixPairs.add(key);
    }
}
function validate(config) {
    const validated = config.map((cfg) => validateSingle(cfg));
    assertUnique(validated, "codebase");
    assertUniqueSourcePrefixPair(validated);
    return validated;
}
exports.validate = validate;
function normalizeAndValidate(config) {
    return validate(normalize(config));
}
exports.normalizeAndValidate = normalizeAndValidate;
function configForCodebase(config, codebase) {
    const codebaseCfg = config.find((c) => c.codebase === codebase);
    if (!codebaseCfg) {
        throw new error_1.FirebaseError(`No functions config found for codebase ${codebase}`);
    }
    return codebaseCfg;
}
exports.configForCodebase = configForCodebase;
