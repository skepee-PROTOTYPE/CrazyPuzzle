"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newUniqueId = exports.toDNSCompatibleId = exports.actuate = exports.askQuestions = void 0;
const path_1 = require("path");
const clc = require("colorette");
const fs = require("fs-extra");
const prompt_1 = require("../../../prompt");
const provisionCloudSql_1 = require("../../../dataconnect/provisionCloudSql");
const freeTrial_1 = require("../../../dataconnect/freeTrial");
const cloudsql = require("../../../gcp/cloudsql/cloudsqladmin");
const ensureApis_1 = require("../../../dataconnect/ensureApis");
const client_1 = require("../../../dataconnect/client");
const types_1 = require("../../../dataconnect/types");
const names_1 = require("../../../dataconnect/names");
const logger_1 = require("../../../logger");
const templates_1 = require("../../../templates");
const utils_1 = require("../../../utils");
Object.defineProperty(exports, "newUniqueId", { enumerable: true, get: function () { return utils_1.newUniqueId; } });
const cloudbilling_1 = require("../../../gcp/cloudbilling");
const sdk = require("./sdk");
const fdcExperience_1 = require("../../../gemini/fdcExperience");
const configstore_1 = require("../../../configstore");
const track_1 = require("../../../track");
const DATACONNECT_YAML_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/dataconnect.yaml");
const CONNECTOR_YAML_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/connector.yaml");
const SCHEMA_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/schema.gql");
const QUERIES_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/queries.gql");
const MUTATIONS_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/mutations.gql");
const emptyConnector = {
    id: "example",
    path: "./example",
    files: [],
};
const defaultConnector = {
    id: "example",
    path: "./example",
    files: [
        {
            path: "queries.gql",
            content: QUERIES_TEMPLATE,
        },
        {
            path: "mutations.gql",
            content: MUTATIONS_TEMPLATE,
        },
    ],
};
const defaultSchema = { path: "schema.gql", content: SCHEMA_TEMPLATE };
async function askQuestions(setup) {
    const info = {
        analyticsFlow: "cli",
        appDescription: "",
        serviceId: "",
        locationId: "",
        cloudSqlInstanceId: "",
        cloudSqlDatabase: "",
    };
    if (setup.projectId) {
        const hasBilling = await (0, cloudbilling_1.isBillingEnabled)(setup);
        await (0, ensureApis_1.ensureApis)(setup.projectId);
        await promptForExistingServices(setup, info);
        if (!info.serviceGql) {
            if (!configstore_1.configstore.get("gemini")) {
                (0, utils_1.logBullet)("Learn more about Gemini in Firebase and how it uses your data: https://firebase.google.com/docs/gemini-in-firebase#how-gemini-in-firebase-uses-your-data");
            }
            info.appDescription = await (0, prompt_1.input)({
                message: `Describe your app to automatically generate a schema with Gemini [Enter to skip]:`,
            });
            if (info.appDescription) {
                configstore_1.configstore.set("gemini", true);
                await (0, ensureApis_1.ensureGIFApis)(setup.projectId);
            }
        }
        if (hasBilling) {
            await promptForCloudSQL(setup, info);
        }
    }
    setup.featureInfo = setup.featureInfo || {};
    setup.featureInfo.dataconnect = info;
    await sdk.askQuestions(setup);
}
exports.askQuestions = askQuestions;
async function actuate(setup, config, options) {
    var _a;
    const dir = config.get("dataconnect.source", "dataconnect");
    const dataDir = config.get("emulators.dataconnect.dataDir", `${dir}/.dataconnect/pgliteData`);
    config.set("emulators.dataconnect.dataDir", dataDir);
    const info = (_a = setup.featureInfo) === null || _a === void 0 ? void 0 : _a.dataconnect;
    if (!info) {
        throw new Error("Data Connect feature RequiredInfo is not provided");
    }
    info.serviceId = info.serviceId || defaultServiceId();
    info.cloudSqlInstanceId = info.cloudSqlInstanceId || `${info.serviceId.toLowerCase()}-fdc`;
    info.locationId = info.locationId || `us-central1`;
    info.cloudSqlDatabase = info.cloudSqlDatabase || `fdcdb`;
    try {
        await actuateWithInfo(setup, config, info, options);
        await sdk.actuate(setup, config);
    }
    finally {
        void (0, track_1.trackGA4)("dataconnect_init", {
            project_status: setup.projectId ? (setup.isBillingEnabled ? "blaze" : "spark") : "missing",
            flow: info.analyticsFlow,
        });
    }
    if (info.appDescription) {
        setup.instructions.push(`You can visualize the Data Connect Schema in Firebase Console:

    https://console.firebase.google.com/project/${setup.projectId}/dataconnect/locations/${info.locationId}/services/${info.serviceId}/schema`);
    }
    if (!setup.isBillingEnabled) {
        setup.instructions.push((0, freeTrial_1.upgradeInstructions)(setup.projectId || "your-firebase-project"));
    }
    setup.instructions.push(`Install the Data Connect VS Code Extensions. You can explore Data Connect Query on local pgLite and Cloud SQL Postgres Instance.`);
}
exports.actuate = actuate;
async function actuateWithInfo(setup, config, info, options) {
    const projectId = setup.projectId;
    if (!projectId) {
        info.analyticsFlow += "_save_template";
        return await writeFiles(config, info, { schemaGql: [defaultSchema], connectors: [defaultConnector] }, options);
    }
    const hasBilling = await (0, cloudbilling_1.isBillingEnabled)(setup);
    if (hasBilling) {
        await (0, provisionCloudSql_1.setupCloudSql)({
            projectId: projectId,
            location: info.locationId,
            instanceId: info.cloudSqlInstanceId,
            databaseId: info.cloudSqlDatabase,
            requireGoogleMlIntegration: false,
        });
    }
    if (!info.appDescription) {
        if (info.serviceGql) {
            info.analyticsFlow += "_save_downloaded";
            return await writeFiles(config, info, info.serviceGql, options);
        }
        info.analyticsFlow += "_save_template";
        return await writeFiles(config, info, { schemaGql: [defaultSchema], connectors: [defaultConnector] }, options);
    }
    const serviceName = `projects/${projectId}/locations/${info.locationId}/services/${info.serviceId}`;
    const serviceAlreadyExists = !(await (0, client_1.createService)(projectId, info.locationId, info.serviceId));
    const schemaGql = await (0, utils_1.promiseWithSpinner)(() => (0, fdcExperience_1.generateSchema)(info.appDescription, projectId), "Generating the Data Connect Schema...");
    const schemaFiles = [{ path: "schema.gql", content: schemaGql }];
    if (serviceAlreadyExists) {
        (0, utils_1.logLabeledError)("dataconnect", `Data Connect Service ${serviceName} already exists. Skip saving them...`);
        info.analyticsFlow += "_save_gemini_service_already_exists";
        return await writeFiles(config, info, { schemaGql: schemaFiles, connectors: [] }, options);
    }
    await (0, utils_1.promiseWithSpinner)(async () => {
        const [saveSchemaGql, waitForCloudSQLProvision] = schemasDeploySequence(projectId, info, schemaFiles, hasBilling);
        await (0, client_1.upsertSchema)(saveSchemaGql);
        if (waitForCloudSQLProvision) {
            void (0, client_1.upsertSchema)(waitForCloudSQLProvision);
        }
    }, "Saving the Data Connect Schema...");
    try {
        const [operationGql, seedDataGql] = await (0, utils_1.promiseWithSpinner)(() => Promise.all([
            (0, fdcExperience_1.generateOperation)(fdcExperience_1.PROMPT_GENERATE_CONNECTOR, serviceName, projectId),
            (0, fdcExperience_1.generateOperation)(fdcExperience_1.PROMPT_GENERATE_SEED_DATA, serviceName, projectId),
        ]), "Generating the Data Connect Operations...");
        const connectors = [
            {
                id: "example",
                path: "./example",
                files: [
                    {
                        path: "queries.gql",
                        content: operationGql,
                    },
                ],
            },
        ];
        info.analyticsFlow += "_save_gemini";
        await writeFiles(config, info, { schemaGql: schemaFiles, connectors: connectors, seedDataGql: seedDataGql }, options);
    }
    catch (err) {
        (0, utils_1.logLabeledError)("dataconnect", `Operation Generation failed...`);
        info.analyticsFlow += "_save_gemini_operation_error";
        await writeFiles(config, info, { schemaGql: schemaFiles, connectors: [] }, options);
        throw err;
    }
}
function schemasDeploySequence(projectId, info, schemaFiles, linkToCloudSql) {
    const serviceName = `projects/${projectId}/locations/${info.locationId}/services/${info.serviceId}`;
    if (!linkToCloudSql) {
        return [
            {
                name: `${serviceName}/schemas/${types_1.SCHEMA_ID}`,
                datasources: [{ postgresql: {} }],
                source: {
                    files: schemaFiles,
                },
            },
        ];
    }
    return [
        {
            name: `${serviceName}/schemas/${types_1.SCHEMA_ID}`,
            datasources: [
                {
                    postgresql: {
                        database: info.cloudSqlDatabase,
                        cloudSql: {
                            instance: `projects/${projectId}/locations/${info.locationId}/instances/${info.cloudSqlInstanceId}`,
                        },
                        schemaValidation: "NONE",
                    },
                },
            ],
            source: {
                files: schemaFiles,
            },
        },
        {
            name: `${serviceName}/schemas/${types_1.SCHEMA_ID}`,
            datasources: [
                {
                    postgresql: {
                        database: info.cloudSqlDatabase,
                        cloudSql: {
                            instance: `projects/${projectId}/locations/${info.locationId}/instances/${info.cloudSqlInstanceId}`,
                        },
                        schemaMigration: "MIGRATE_COMPATIBLE",
                    },
                },
            ],
            source: {
                files: schemaFiles,
            },
        },
    ];
}
async function writeFiles(config, info, serviceGql, options) {
    const dir = config.get("dataconnect.source") || "dataconnect";
    const subbedDataconnectYaml = subDataconnectYamlValues(Object.assign(Object.assign({}, info), { connectorDirs: serviceGql.connectors.map((c) => c.path) }));
    config.set("dataconnect", { source: dir });
    await config.askWriteProjectFile((0, path_1.join)(dir, "dataconnect.yaml"), subbedDataconnectYaml, !!options.force, true);
    if (serviceGql.seedDataGql) {
        await config.askWriteProjectFile((0, path_1.join)(dir, "seed_data.gql"), serviceGql.seedDataGql, !!options.force);
    }
    if (serviceGql.schemaGql.length) {
        for (const f of serviceGql.schemaGql) {
            await config.askWriteProjectFile((0, path_1.join)(dir, "schema", f.path), f.content, !!options.force);
        }
    }
    else {
        fs.ensureFileSync((0, path_1.join)(dir, "schema", "schema.gql"));
    }
    for (const c of serviceGql.connectors) {
        await writeConnectorFiles(config, c, options);
    }
}
async function writeConnectorFiles(config, connectorInfo, options) {
    const subbedConnectorYaml = subConnectorYamlValues({ connectorId: connectorInfo.id });
    const dir = config.get("dataconnect.source") || "dataconnect";
    await config.askWriteProjectFile((0, path_1.join)(dir, connectorInfo.path, "connector.yaml"), subbedConnectorYaml, !!options.force, true);
    for (const f of connectorInfo.files) {
        await config.askWriteProjectFile((0, path_1.join)(dir, connectorInfo.path, f.path), f.content, !!options.force);
    }
}
function subDataconnectYamlValues(replacementValues) {
    const replacements = {
        serviceId: "__serviceId__",
        cloudSqlDatabase: "__cloudSqlDatabase__",
        cloudSqlInstanceId: "__cloudSqlInstanceId__",
        connectorDirs: "__connectorDirs__",
        locationId: "__location__",
    };
    let replaced = DATACONNECT_YAML_TEMPLATE;
    for (const [k, v] of Object.entries(replacementValues)) {
        replaced = replaced.replace(replacements[k], JSON.stringify(v));
    }
    return replaced;
}
function subConnectorYamlValues(replacementValues) {
    const replacements = {
        connectorId: "__connectorId__",
    };
    let replaced = CONNECTOR_YAML_TEMPLATE;
    for (const [k, v] of Object.entries(replacementValues)) {
        replaced = replaced.replace(replacements[k], JSON.stringify(v));
    }
    return replaced;
}
async function promptForExistingServices(setup, info) {
    var _a, _b, _c, _d, _e;
    if (!setup.projectId) {
        return;
    }
    const existingServices = await (0, client_1.listAllServices)(setup.projectId);
    if (!existingServices.length) {
        return;
    }
    const existingServicesAndSchemas = await Promise.all(existingServices.map(async (s) => {
        return { service: s, schema: await (0, client_1.getSchema)(s.name) };
    }));
    const choice = await chooseExistingService(existingServicesAndSchemas);
    if (!choice) {
        const existingServiceIds = existingServices.map((s) => s.name.split("/").pop());
        info.serviceId = (0, utils_1.newUniqueId)(defaultServiceId(), existingServiceIds);
        info.analyticsFlow += "_pick_new_service";
        return;
    }
    info.analyticsFlow += "_pick_existing_service";
    const serviceName = (0, names_1.parseServiceName)(choice.service.name);
    info.serviceId = serviceName.serviceId;
    info.locationId = serviceName.location;
    info.serviceGql = {
        schemaGql: [],
        connectors: [emptyConnector],
    };
    if (choice.schema) {
        const primaryDatasource = choice.schema.datasources.find((d) => d.postgresql);
        if ((_b = (_a = primaryDatasource === null || primaryDatasource === void 0 ? void 0 : primaryDatasource.postgresql) === null || _a === void 0 ? void 0 : _a.cloudSql) === null || _b === void 0 ? void 0 : _b.instance) {
            const instanceName = (0, names_1.parseCloudSQLInstanceName)(primaryDatasource.postgresql.cloudSql.instance);
            info.cloudSqlInstanceId = instanceName.instanceId;
        }
        if ((_c = choice.schema.source.files) === null || _c === void 0 ? void 0 : _c.length) {
            info.serviceGql.schemaGql = choice.schema.source.files;
        }
        info.cloudSqlDatabase = (_e = (_d = primaryDatasource === null || primaryDatasource === void 0 ? void 0 : primaryDatasource.postgresql) === null || _d === void 0 ? void 0 : _d.database) !== null && _e !== void 0 ? _e : "";
        const connectors = await (0, client_1.listConnectors)(choice.service.name, [
            "connectors.name",
            "connectors.source.files",
        ]);
        if (connectors.length) {
            info.serviceGql.connectors = connectors.map((c) => {
                const id = c.name.split("/").pop();
                return {
                    id,
                    path: connectors.length === 1 ? "./example" : `./${id}`,
                    files: c.source.files || [],
                };
            });
        }
    }
    return;
}
async function chooseExistingService(existing) {
    const fdcConnector = (0, utils_1.envOverride)("FDC_CONNECTOR", "");
    const fdcService = (0, utils_1.envOverride)("FDC_SERVICE", "");
    const serviceEnvVar = fdcConnector || fdcService;
    if (serviceEnvVar) {
        const [serviceLocationFromEnvVar, serviceIdFromEnvVar] = serviceEnvVar.split("/");
        const serviceFromEnvVar = existing.find((s) => {
            const serviceName = (0, names_1.parseServiceName)(s.service.name);
            return (serviceName.serviceId === serviceIdFromEnvVar &&
                serviceName.location === serviceLocationFromEnvVar);
        });
        if (serviceFromEnvVar) {
            (0, utils_1.logBullet)(`Picking up the existing service ${clc.bold(serviceLocationFromEnvVar + "/" + serviceIdFromEnvVar)}.`);
            return serviceFromEnvVar;
        }
        const envVarName = fdcConnector ? "FDC_CONNECTOR" : "FDC_SERVICE";
        (0, utils_1.logWarning)(`Unable to pick up an existing service based on ${envVarName}=${serviceEnvVar}.`);
    }
    const choices = existing.map((s) => {
        const serviceName = (0, names_1.parseServiceName)(s.service.name);
        return {
            name: `${serviceName.location}/${serviceName.serviceId}`,
            value: s,
        };
    });
    choices.push({ name: "Create a new service", value: undefined });
    return await (0, prompt_1.select)({
        message: "Your project already has existing services. Which would you like to set up local files for?",
        choices,
    });
}
async function promptForCloudSQL(setup, info) {
    if (!setup.projectId) {
        return;
    }
    if (info.cloudSqlInstanceId === "") {
        const instances = await cloudsql.listInstances(setup.projectId);
        let choices = instances.map((i) => {
            var _a;
            let display = `${i.name} (${i.region})`;
            if (((_a = i.settings.userLabels) === null || _a === void 0 ? void 0 : _a["firebase-data-connect"]) === "ft") {
                display += " (no cost trial)";
            }
            return { name: display, value: i.name, location: i.region };
        });
        choices = choices.filter((c) => info.locationId === "" || info.locationId === c.location);
        if (choices.length) {
            if (!(await (0, freeTrial_1.checkFreeTrialInstanceUsed)(setup.projectId))) {
                choices.push({ name: "Create a new free trial instance", value: "", location: "" });
            }
            else {
                choices.push({ name: "Create a new CloudSQL instance", value: "", location: "" });
            }
            info.cloudSqlInstanceId = await (0, prompt_1.select)({
                message: `Which CloudSQL instance would you like to use?`,
                choices,
            });
            if (info.cloudSqlInstanceId !== "") {
                info.analyticsFlow += "_pick_existing_csql";
                info.locationId = choices.find((c) => c.value === info.cloudSqlInstanceId).location;
            }
            else {
                info.analyticsFlow += "_pick_new_csql";
                info.cloudSqlInstanceId = await (0, prompt_1.input)({
                    message: `What ID would you like to use for your new CloudSQL instance?`,
                    default: (0, utils_1.newUniqueId)(`${defaultServiceId().toLowerCase()}-fdc`, instances.map((i) => i.name)),
                });
            }
        }
    }
    if (info.locationId === "") {
        const choices = await locationChoices(setup);
        info.locationId = await (0, prompt_1.select)({
            message: "What location would like to use?",
            choices,
            default: "us-central1",
        });
    }
    if (info.cloudSqlInstanceId !== "" && info.cloudSqlDatabase === "") {
        try {
            const dbs = await cloudsql.listDatabases(setup.projectId, info.cloudSqlInstanceId);
            const existing = dbs.map((d) => d.name);
            info.cloudSqlDatabase = (0, utils_1.newUniqueId)("fdcdb", existing);
        }
        catch (err) {
            logger_1.logger.debug(`[dataconnect] Cannot list databases during init: ${err}`);
        }
    }
    return;
}
async function locationChoices(setup) {
    if (setup.projectId) {
        const locations = await (0, client_1.listLocations)(setup.projectId);
        return locations.map((l) => {
            return { name: l, value: l };
        });
    }
    else {
        return [
            { name: "us-central1", value: "us-central1" },
            { name: "europe-north1", value: "europe-north1" },
            { name: "europe-central2", value: "europe-central2" },
            { name: "europe-west1", value: "europe-west1" },
            { name: "southamerica-west1", value: "southamerica-west1" },
            { name: "us-east4", value: "us-east4" },
            { name: "us-west1", value: "us-west1" },
            { name: "asia-southeast1", value: "asia-southeast1" },
        ];
    }
}
function defaultServiceId() {
    return toDNSCompatibleId((0, path_1.basename)(process.cwd()));
}
function toDNSCompatibleId(id) {
    id = (0, path_1.basename)(id)
        .toLowerCase()
        .replaceAll(/[^a-z0-9-]/g, "")
        .slice(0, 63);
    while (id.endsWith("-") && id.length) {
        id = id.slice(0, id.length - 1);
    }
    while (id.startsWith("-") && id.length) {
        id = id.slice(1, id.length);
    }
    return id || "app";
}
exports.toDNSCompatibleId = toDNSCompatibleId;
